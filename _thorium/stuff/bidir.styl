
// these mixins allow you to simply designate horizontal margins and
// paddings that will flip depending on reading direction.

// start = The direction the reading direction starts.
// end = The direction the reading direction ends.


margin-start(l)
	html[dir='ltr'] & { margin-left: l }
	html[dir='rtl'] & { margin-right: l }


margin-end(l)
	html[dir='ltr'] & { margin-right: l }
	html[dir='rtl'] & { margin-left: l }


padding-start(l)
	html[dir='ltr'] & { padding-left: l }
	html[dir='rtl'] & { padding-right: l }


padding-end(l)
	html[dir='ltr'] & { padding-right: l }
	html[dir='rtl'] & { padding-left: l }





// this provides the real thing and also provides
// fallback substitutions.

text-align(pos)
	if pos == start
		html[dir='ltr'] & { text-align: left }
		html[dir='rtl'] & { text-align: right }
		//text-align: start

	else if pos == end
		html[dir='ltr'] & { text-align: right }
		html[dir='rtl'] & { text-align: left }
		//text-align: end

	else
		text-align: pos
		// THIS IS IMPORTANT. ELSE THIS FUNCTION
		// WILL JUST EAT ANY OTHER VALUE AND NOT SHOW ANYTHING




// alternatives to left: x and right: x when positioning fixed objects.
start(l)
	html[dir='ltr'] & { left: l }
	html[dir='rtl'] & { right: l }

end(l)
	html[dir='ltr'] & { right: l }
	html[dir='rtl'] & { left: l }
